name: Refresh Build
on:
  workflow_dispatch:
  repository_dispatch:
    types:
      - build_trigger

permissions:
  contents: write

jobs:
  ## ── 第一步：获取最新 Tag 并删除对应 Release 下的旧资产 ──
  fetch_and_clean:
    name: 获取最新 Tag 并清理旧资产
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.get_latest_tag.outputs.Tag }}
      upload_url: ${{ steps.get_upload_url.outputs.UPLOAD_URL }}
    steps:
      - name: Checkout 仓库（完整拉取）
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: 获取最新 Tag
        id: get_latest_tag
        run: |
          # 按创建时间排序，取最新 Tag
          LATEST_TAG=$(git for-each-ref --sort=-creatordate --format='%(refname:short)' refs/tags | head -n 1)
          echo "Tag=$LATEST_TAG" >> "$GITHUB_OUTPUT"
          echo "获取到最新 Tag: $LATEST_TAG"

      - name: 删除最新 Release 下所有旧资产
        uses: andreaswilli/delete-release-assets-action@main
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          tag: ${{ steps.get_latest_tag.outputs.Tag }}
          deleteOnlyFromDrafts: false

      - name: 获取对应 Release 的 upload_url
        id: get_upload_url
        run: |
          RELEASE_JSON=$(curl -s \
            -H "Accept: application/vnd.github.v3+json" \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/${{ steps.get_latest_tag.outputs.Tag }}")
          UPLOAD_URL=$(echo "$RELEASE_JSON" | jq -r '.upload_url' | sed -E 's|\{\?name,label\}||')
          echo "UPLOAD_URL=$UPLOAD_URL" >> "$GITHUB_OUTPUT"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # ── 新增步骤：创建并上传“刷新提示”文件 ──
      - name: 创建刷新提示文件
        run: |
          echo "刷新构建中，请稍后再试" > 刷新构建中，请稍后再试.txt

      - name: 上传刷新提示文件到 Release
        run: |
          curl -s -X POST "${{ steps.get_upload_url.outputs.UPLOAD_URL }}?name=刷新构建中，请稍后再试.txt" \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "Content-Type: text/plain" \
            --data-binary @刷新构建中，请稍后再试.txt

  ## ── 并行构建：Linux AMD64 ──
  build-linux:
    name: 构建 Linux AMD64 可执行文件
    needs: fetch_and_clean
    runs-on: ubuntu-latest
    env:
      BUILD_TAG: ${{ needs.fetch_and_clean.outputs.tag }}
    outputs:
      artifact_path: ${{ steps.set_artifact_path.outputs.ARTIFACT_PATH }}
    steps:
      - name: Checkout 代码 (按最新 Tag)
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.fetch_and_clean.outputs.tag }}

      - name: Setup Python (Linux)
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'

      - name: Checkout 私有仓库 B 并编译 Cython 扩展 (Linux)
        uses: actions/checkout@v4
        with:
          repository: zhongbai2333/Fanqie-Novel-Official-API-Helper
          token: ${{ secrets.PYD_PAT }}
          path: B

      - name: 安装 B 的构建依赖 (Linux)
        run: |
          python -m pip install --upgrade pip
          pip install Cython
          if [ -f B/requirements.txt ]; then
            pip install -r B/requirements.txt
          fi

      - name: 编译 Cython 扩展 (Linux)
        run: |
          cd B
          python setup.py build_ext --inplace
          cd ..

      - name: 将编译好的 .so 文件复制到仓库根目录 (Linux)
        run: |
          cp B/client_mod.*.so . || true

      - name: 缓存 A 仓库的 pip 依赖 (Linux)
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: 安装 A 仓库所需依赖 (Linux)
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pyinstaller

      - name: 使用 PyInstaller 打包成可执行文件 (Linux)
        run: |
          pyinstaller \
            --onefile \
            --strip \
            --exclude-module _bootlocale \
            --exclude-module _cffi_backend \
            --collect-data fake_useragent \
            --hidden-import=portalocker \
            -i img/Tomato-downlaoder-ico.ico \
            --name=TomatoNovelDownloader-Linux_amd64-${{ env.BUILD_TAG }} \
            --clean \
            main.py
        env:
          RELEASE_TAG: ${{ env.BUILD_TAG }}

      - name: 设置输出产物路径 (Linux)
        id: set_artifact_path
        run: |
          echo "ARTIFACT_PATH=dist/TomatoNovelDownloader-Linux_amd64-${{ env.BUILD_TAG }}" >> "$GITHUB_OUTPUT"

  ## ── 并行构建：Linux ARM64 ──
  build-linux-arm64:
    name: 构建 Linux ARM64 可执行文件
    needs: fetch_and_clean
    runs-on: ubuntu-24.04-arm
    env:
      BUILD_TAG: ${{ needs.fetch_and_clean.outputs.tag }}
    outputs:
      artifact_path: ${{ steps.set_artifact_path.outputs.ARTIFACT_PATH }}
    steps:
      - name: Checkout 代码 (按最新 Tag)
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.fetch_and_clean.outputs.tag }}

      - name: Setup Python (Linux ARM64)
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'

      - name: Checkout 私有仓库 B 并编译 Cython 扩展 (Linux ARM64)
        uses: actions/checkout@v4
        with:
          repository: zhongbai2333/Fanqie-Novel-Official-API-Helper
          token: ${{ secrets.PYD_PAT }}
          path: B

      - name: 安装 B 的构建依赖 (Linux ARM64)
        run: |
          python -m pip install --upgrade pip
          pip install Cython
          if [ -f B/requirements.txt ]; then
            pip install -r B/requirements.txt
          fi

      - name: 编译 Cython 扩展 (Linux ARM64)
        run: |
          cd B
          python setup.py build_ext --inplace
          cd ..

      - name: 将编译好的 .so 文件复制到仓库根目录 (Linux ARM64)
        run: |
          cp B/client_mod.*.so . || true

      - name: 缓存 A 仓库的 pip 依赖 (Linux ARM64)
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: 安装 A 仓库所需依赖 (Linux ARM64)
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pyinstaller

      - name: 使用 PyInstaller 打包成可执行文件 (Linux ARM64)
        run: |
          pyinstaller \
            --onefile \
            --strip \
            --exclude-module _bootlocale \
            --exclude-module _cffi_backend \
            --collect-data fake_useragent \
            --hidden-import=portalocker \
            -i img/Tomato-downlaoder-ico.ico \
            --name=TomatoNovelDownloader-Linux_arm64-${{ env.BUILD_TAG }} \
            --clean \
            main.py
        env:
          RELEASE_TAG: ${{ env.BUILD_TAG }}

      - name: 设置输出产物路径 (Linux ARM64)
        id: set_artifact_path
        run: |
          echo "ARTIFACT_PATH=dist/TomatoNovelDownloader-Linux_arm64-${{ env.BUILD_TAG }}" >> "$GITHUB_OUTPUT"

  ## ── 并行构建：Windows ──
  build-windows:
    name: 构建 Windows 可执行文件
    needs: fetch_and_clean
    runs-on: windows-latest
    env:
      BUILD_TAG: ${{ needs.fetch_and_clean.outputs.tag }}
    outputs:
      artifact_path: ${{ steps.set_artifact_path.outputs.ARTIFACT_PATH }}
    steps:
      - name: Checkout 代码 (按最新 Tag)
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.fetch_and_clean.outputs.tag }}

      - name: Setup Python (Windows)
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'

      - name: Checkout 私有仓库 B 并编译 Cython 扩展 (Windows)
        uses: actions/checkout@v4
        with:
          repository: zhongbai2333/Fanqie-Novel-Official-API-Helper
          token: ${{ secrets.PYD_PAT }}
          path: B

      - name: 安装 B 的构建依赖 (Windows)
        shell: pwsh
        run: |
          python -m pip install --upgrade pip
          pip install Cython
          if (Test-Path "B\\requirements.txt") {
            pip install -r B\\requirements.txt
          }

      - name: 编译 Cython 扩展 (Windows)
        shell: pwsh
        run: |
          cd B
          python setup.py build_ext --inplace
          cd ..

      - name: 将编译好的 .pyd 文件复制到仓库根目录 (Windows)
        shell: pwsh
        run: |
          Copy-Item "B\\client_mod*.pyd" "." -Force

      - name: 缓存 A 仓库的 pip 依赖 (Windows)
        uses: actions/cache@v4
        with:
          path: ~\AppData\Local\pip\Cache
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: 安装 A 仓库所需依赖 (Windows)
        shell: pwsh
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pyinstaller

      - name: 下载并准备 UPX (Windows)
        shell: pwsh
        run: |
          $url = "https://github.com/upx/upx/releases/download/v5.0.0/upx-5.0.0-win64.zip"
          Invoke-WebRequest -Uri $url -OutFile upx.zip
          Expand-Archive -Path upx.zip -DestinationPath upx

      - name: 使用 PyInstaller 打包成可执行文件 (Windows)
        shell: pwsh
        run: |
          $upxDir = "$pwd\upx\upx-5.0.0-win64"
          if (Test-Path "$upxDir\upx.exe") {
            icacls "$upxDir\upx.exe" /grant Everyone:F
          }
          pyinstaller --onefile `
            --upx-dir "$upxDir" `
            --collect-data fake_useragent `
            --hidden-import=portalocker `
            -i img/Tomato-downlaoder-ico.ico `
            --name=TomatoNovelDownloader-Win64-${{ env.BUILD_TAG }} `
            --clean `
            main.py

      - name: 设置输出产物路径 (Windows)
        id: set_artifact_path
        shell: pwsh
        run: |
          echo "ARTIFACT_PATH=dist/TomatoNovelDownloader-Win64-${{ env.BUILD_TAG }}.exe" >> $env:GITHUB_OUTPUT

  ## ── 并行构建：macOS ──
  build-macos:
    name: 构建 macOS 可执行文件
    needs: fetch_and_clean
    runs-on: macos-latest
    env:
      BUILD_TAG: ${{ needs.fetch_and_clean.outputs.tag }}
    outputs:
      artifact_path: ${{ steps.set_artifact_path.outputs.ARTIFACT_PATH }}
    steps:
      - name: Checkout 代码 (按最新 Tag)
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.fetch_and_clean.outputs.tag }}

      - name: Setup Python (macOS)
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'

      - name: Checkout 私有仓库 B 并编译 Cython 扩展 (macOS)
        uses: actions/checkout@v4
        with:
          repository: zhongbai2333/Fanqie-Novel-Official-API-Helper
          token: ${{ secrets.PYD_PAT }}
          path: B

      - name: 安装 B 的构建依赖 (macOS)
        run: |
          python -m pip install --upgrade pip
          pip install Cython
          if [ -f B/requirements.txt ]; then
            pip install -r B/requirements.txt
          fi

      - name: 编译 Cython 扩展 (macOS)
        run: |
          cd B
          python setup.py build_ext --inplace
          cd ..

      - name: 将编译好的 .so 文件复制到仓库根目录 (macOS)
        run: |
          cp B/client_mod.*.so . || true

      - name: 缓存 A 仓库的 pip 依赖 (macOS)
        uses: actions/cache@v4
        with:
          path: ~/Library/Caches/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: 安装 A 仓库所需依赖 (macOS)
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pyinstaller

      - name: 使用 PyInstaller 打包成可执行文件 (macOS)
        run: |
          pyinstaller \
            --onefile \
            --strip \
            --exclude-module _bootlocale \
            --exclude-module _cffi_backend \
            --collect-data fake_useragent \
            --hidden-import=portalocker \
            -i img/Tomato-downlaoder-ico.ico \
            --name=TomatoNovelDownloader-macOS_arm64-${{ env.BUILD_TAG }} \
            --clean \
            main.py
        env:
          RELEASE_TAG: ${{ env.BUILD_TAG }}

      - name: 设置输出产物路径 (macOS)
        id: set_artifact_path
        run: |
          echo "ARTIFACT_PATH=dist/TomatoNovelDownloader-macOS_arm64-${{ env.BUILD_TAG }}" >> "$GITHUB_OUTPUT"

  ## ── 最后一步：一次性上传所有产物并删除“刷新提示”文件 ──
  upload_assets:
    name: 上传构建产物到 Release
    needs:
      - fetch_and_clean
      - build-linux
      - build-linux-arm64
      - build-windows
      - build-macos
    runs-on: ubuntu-latest
    steps:
      - name: Debug 打印产物路径与上传信息
        run: |
          echo "Linux AMD64 产物：${{ needs.build-linux.outputs.artifact_path }}"
          echo "Linux ARM64 产物：${{ needs.build-linux-arm64.outputs.artifact_path }}"
          echo "Windows 产物：${{ needs.build-windows.outputs.artifact_path }}"
          echo "macOS 产物：${{ needs.build-macos.outputs.artifact_path }}"
          echo "Target Release Tag：${{ needs.fetch_and_clean.outputs.tag }}"

      - name: 上传所有构建产物 (使用 softprops/action-gh-release@v2)
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.fetch_and_clean.outputs.tag }}
          files: |
            ${{ needs.build-linux.outputs.artifact_path }}
            ${{ needs.build-linux-arm64.outputs.artifact_path }}
            ${{ needs.build-macos.outputs.artifact_path }}
            ${{ needs.build-windows.outputs.artifact_path }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: 删除刷新提示文件
        run: |
          # 获取 Release 资产列表
          ASSETS_JSON=$(curl -s \
            -H "Accept: application/vnd.github.v3+json" \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/releases/tags/${{ needs.fetch_and_clean.outputs.tag }}")
          # 找到名为 刷新构建中，请稍后再试.txt 的 asset id
          ASSET_ID=$(echo "$ASSETS_JSON" | jq -r '.assets[] | select(.name=="刷新构建中，请稍后再试.txt") .id')
          if [ "$ASSET_ID" != "null" ] && [ -n "$ASSET_ID" ]; then
            # 删除该 asset
            curl -s -X DELETE \
              -H "Accept: application/vnd.github.v3+json" \
              -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/releases/assets/$ASSET_ID"
          fi
